--@name Better Reticle
--@author Ally for Hire / Merydian9
--@shared

-- Just a base for stuff because I'm not working on anything that would use this
-- Good luck getting text working

if SERVER then
    -- Handling of wire inputs, since it's starfall you have to network
    local inputs = {"Target"}
    local inputTypes = {"Vector"}
    
    wire.adjustInputs( inputs, inputTypes )
    
    -- This is not necessarily the most efficient way to do this, you could just update an individual element instead of the whole array
    hook.add("input", "", function(input, value)
        local wireInformation = {}
        for k in ipairs( inputs ) do
            local name = inputs[k]
            wireInformation[name] = wire.ports[name]
        end
        
        net.start( "wiresend" )
        net.writeTable( wireInformation )
        net.send( owner() )
    end)

elseif CLIENT then
    if player() ~= owner() then return end
    
    -- Customizable bits
    local SCALE = 1 -- Scale of the HUD
    local AVGDISTANCE = 40 -- Distance of the Pilot from the HUD    
    
    -- Variable initialization
    local PLAYER = owner()
    local FOV = 90
    local TARGET = Vector()
    local SCREEN = chip():getLinkedComponents()[1]
    if SCREEN == nil then return end
    
    --local HOLO = hologram.create(Vector(), Angle(), "models/hunter/blocks/cube025x025x025.mdl", Vector(1))
    
    -- Gotta make the screen background invisible
    render.setBackgroundColor(Color(255,255,255,0), SCREEN)
    
    -- These are just for drawing rectangles from the center lol
    local function _drawRect(x, y, w, h)
        render.drawRect(x - w/2, y - h/2, w, h)    
    end
    local function _drawRect(x, y, w, h, t)
        render.drawRect(x - w/2, y - h/2, w, h, t)    
    end
    local function _drawRectOutline(x, y, w, h)
        render.drawRectOutline(x - w/2, y - h/2, w, h)    
    end
    local function _drawRectOutline(x, y, w, h, t)
        render.drawRectOutline(x - w/2, y - h/2, w, h, t)    
    end
    
    -- The following 2 functions are for converting a world position into a position on the screen relative to the player
    local function _toScreenCoords(localcoords)
        return {256 + -localcoords.y / 11.5 * 256, 256 + -localcoords.z / 11.5 * 256}
    end
    local function conv3dto2d(Origin, Target)
        local LocalOriginScreen = worldToLocal(Origin, chip():getAngles(), SCREEN:getPos(), chip():getAngles())
        local DistanceToFlat = math.sqrt(LocalOriginScreen.y^2 + LocalOriginScreen.x^2)
        Hit = Origin + (Target - Origin):getNormalized() * DistanceToFlat
        local LocalCoords = worldToLocal(Hit, chip():getAngles(), SCREEN:getPos(), chip():getAngles())
        local ScreenCoords = _toScreenCoords(LocalCoords)
        return {ScreenCoords[1], ScreenCoords[2], Origin:getDistance(Hit)}    
    end
    
    -- And now we finally get to rendering stuff
    hook.add("render", "", function()
        local ORIGIN = PLAYER:getEyePos()
        local JETFORWARD =  chip():getPos() + chip():getForward() * 1000
        local CENTERCOORDS = conv3dto2d(ORIGIN, JETFORWARD)
        local DISTMUL = CENTERCOORDS[3] / AVGDISTANCE * SCALE -- This is to resize based on distance
        local FOVMUL = FOV / 90 -- This is to resize based on zoom, though we don't actually have to now
        
        --HOLO:setPos(JETFORWARD) -- This is just for the sake of debugging
        
        -- CENTERCOORDS is the front of the jet bits, make sure everything you want moving is relative to that.
        -- DISTMUL is so that stuff resizes as you get closer, make sure to multiply everything by that
        -- Do note, rectangles get kinda fucky, and circles get low poly as you get close
        -- Making rectangles thickness DISTMUL will make it display better, but if you get close it will dissapear
        -- Alternatively, not doing this when you get close will make it look stupid
        -- In general things get fucky the closer you get though, keep screens relatively far
        
        render.setColor(Color(255, 255, 255, 255))
        _drawRectOutline(CENTERCOORDS[1], CENTERCOORDS[2], 30 * DISTMUL , 30 * DISTMUL, DISTMUL) -- you have to do this because if it goes below 1, it dissapears 
        render.drawLine(CENTERCOORDS[1] + 15 * DISTMUL, CENTERCOORDS[2], CENTERCOORDS[1] + 30 * DISTMUL, CENTERCOORDS[2])
        render.drawLine(CENTERCOORDS[1] - 15 * DISTMUL, CENTERCOORDS[2], CENTERCOORDS[1] - 30 * DISTMUL, CENTERCOORDS[2])
        render.drawCircle(CENTERCOORDS[1], CENTERCOORDS[2], 60 * DISTMUL)
        render.drawLine(CENTERCOORDS[1] + 5 * DISTMUL, CENTERCOORDS[2], CENTERCOORDS[1] - 5 * DISTMUL, CENTERCOORDS[2])
        render.drawLine(CENTERCOORDS[1], CENTERCOORDS[2] + 5 * DISTMUL, CENTERCOORDS[1], CENTERCOORDS[2] - 5 * DISTMUL)
        
        _drawRectOutline(256, 256, 512, 512, 2) -- Screen outline, mostly for debugging
        
    end)
    
    net.receive("wiresend", function()
        inputs = net.readTable()
        
        --FOV = inputs["FOV"]
        TARGET = inputs["Target"]
    end)
end